class GameManager {
    constructor() {
        this.isBattleActive = false;
        this.isPlayerTurn = true;
        this.player = null;
        this.currentEnemy = null;
        this.enemySystem = new EnemySystem();
        this.rewardSystem = new RewardSystem();
        this.talentSystem = new TalentSystem();
        this.saveManager = new SaveManager(this);
        this.showingRewards = false;
        this.talentPointsEarned = 0;
        this.battleStartTime = 0;
        this.totalPlayTime = 0;
        this.initializeGame();
    }

    initializeGame() {
        this.player = new Entity({ maxHealth: 100 });
        this.currentEnemy = this.enemySystem.createEnemy(1);
        
        this.setupEventListeners();
        this.initializeTalentGrid();
        this.updateUI();
        
        // åˆå§‹åŒ–å­˜æª”ç®¡ç†å™¨
        this.saveManager.initialize();
        
        // å˜—è©¦è‡ªå‹•è¼‰å…¥å­˜æª”
        this.autoLoadGame();

        // åˆå§‹åŒ–éŠæˆ²çµ±è¨ˆ
        this.initializeGameStats();

        console.log('âœ… éŠæˆ²åˆå§‹åŒ–å®Œæˆ');
    }

    initializeGameStats() {
        this.gameStats = {
            totalBattles: 0,
            victories: 0,
            defeats: 0,
            totalDamageDealt: 0,
            totalDamageTaken: 0,
            criticalHits: 0,
            talentsActivated: 0,
            rewardsObtained: 0
        };
    }

    setupEventListeners() {
        // é–‹å§‹æˆ°é¬¥æŒ‰éˆ•
        const startBattleBtn = document.querySelector(CONSTANTS.SELECTORS.START_BATTLE_BTN);
        if (startBattleBtn) {
            startBattleBtn.addEventListener('click', () => this.startBattle());
        }
        
        // å¡ç‰Œé»æ“Šäº‹ä»¶
        document.querySelectorAll('.card').forEach(card => {
            card.addEventListener('click', (e) => this.handleCardClick(e));
        });

        // çå‹µé¸æ“‡äº‹ä»¶å§”è¨—
        document.addEventListener('click', (e) => {
            if (e.target.closest('.reward-option')) {
                this.handleRewardSelection(e);
            }
        });

        // å¤©è³¦é»é¡¯ç¤º
        this.createTalentPointsDisplay();

        // éµç›¤å¿«æ·éµ
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && !this.isBattleActive) {
                this.toggleGameMenu();
            }
        });

        // éŠæˆ²é‡ç½®äº‹ä»¶
        document.addEventListener('gameReset', () => {
            this.handleGameReset();
        });
    }

    createTalentPointsDisplay() {
        const talentPanel = document.querySelector('#talent-panel');
        if (talentPanel && !document.getElementById('talent-points-display')) {
            const pointsDisplay = document.createElement('div');
            pointsDisplay.id = 'talent-points-display';
            pointsDisplay.className = 'talent-points';
            pointsDisplay.textContent = 'å¤©è³¦é»: 0';
            talentPanel.insertBefore(pointsDisplay, talentPanel.firstChild);
        }
    }

    initializeTalentGrid() {
        this.talentSystem.updateTalentUI();
    }

    startBattle() {
        if (this.isBattleActive) return;
        
        this.isBattleActive = true;
        this.isPlayerTurn = true;
        this.battleStartTime = Date.now();
        this.currentEnemy = this.enemySystem.createEnemy(this.enemySystem.enemyCounter);
        this.updateUI();
        
        this.gameStats.totalBattles++;
        if (window.performanceMonitor) {
            window.performanceMonitor.recordBattle();
        }
        
        this.addCombatMessage(`âš”ï¸ æˆ°é¬¥é–‹å§‹ï¼å°æˆ°æ•µäºº ${this.enemySystem.enemyCounter.toString().padStart(3, '0')}`);
        
        // é è¦½æ•µäººç¬¬ä¸€æ¬¡æ”»æ“Š
        this.enemySystem.decideNextAttack(this.currentEnemy, this.player);
        this.updateEnemyNextAttack();
        
        document.querySelector(CONSTANTS.SELECTORS.START_BATTLE_BTN).disabled = true;
        this.setCardsEnabled(true);

        // ç™¼é€æˆ°é¬¥é–‹å§‹äº‹ä»¶
        this.dispatchGameEvent('battleStart', {
            enemyLevel: this.enemySystem.enemyCounter,
            enemyAttributes: this.enemySystem.getCurrentEnemyAttributes()
        });
    }

    async handleCardClick(event) {
        if (!this.isBattleActive || !this.isPlayerTurn) return;
        
        const cardType = event.currentTarget.dataset.type;
        const attackName = BattleSystem.getAttackName(cardType);
        this.addCombatMessage(`ğŸ¯ ä½¿ç”¨äº†${attackName}æ”»æ“Š`);
        
        this.setCardsEnabled(false);
        this.isPlayerTurn = false;
        
        // ç¨å¾®å»¶é²è®“ç©å®¶çœ‹åˆ°è¨Šæ¯
        await this.delay(500);
        
        const result = BattleSystem.calculateDamage(
            this.player,
            this.currentEnemy,
            cardType
        );
        
        // è¨˜éŒ„å‚·å®³çµ±è¨ˆ
        this.gameStats.totalDamageDealt += result.damage;
        if (result.isCrit) {
            this.gameStats.criticalHits++;
        }
        
        if (result.isHit) {
            const critText = result.isCrit ? 'ã€æš´æ“Šï¼ã€‘' : '';
            this.addCombatMessage(`${critText}å‘½ä¸­ï¼é€ æˆ ${result.damage} é»å‚·å®³ (å‘½ä¸­ç‡:${result.hitRate}%)`);
            
            this.currentEnemy.takeDamage(result.damage);
            this.updateUI();
            
            if (!this.currentEnemy.isAlive()) {
                await this.handleEnemyDefeated();
                return;
            }
        } else {
            this.addCombatMessage(`âŒ æ”»æ“Šæœªå‘½ä¸­ï¼é€ æˆ 1 é»å‚·å®³ (å‘½ä¸­ç‡:${result.hitRate}%)`);
            this.currentEnemy.takeDamage(1);
            this.updateUI();
        }
        
        // æ•µäººåæ“Š
        await this.delay(1000);
        await this.enemyTurn();
        
        this.isPlayerTurn = true;
        this.setCardsEnabled(true);
    }

    async enemyTurn() {
        this.addCombatMessage('âš”ï¸ æ•µäººå›åˆ...');
        await this.delay(800);
        
        const attackResult = this.enemySystem.performAttack(this.currentEnemy, this.player);
        
        // é¡¯ç¤ºç‰¹æ®Šæ•ˆæœè¨Šæ¯
        if (attackResult.specialEffect) {
            this.addCombatMessage(attackResult.specialEffect);
            await this.delay(600);
        }
        
        if (attackResult.isHit) {
            const critText = attackResult.isCrit ? 'ã€æš´æ“Šï¼ã€‘' : '';
            this.addCombatMessage(`æ•µäºº${critText}${attackResult.attackDescription}ï¼Œé€ æˆ ${attackResult.damage} é»å‚·å®³`);
            
            // è¨˜éŒ„å‚·å®³çµ±è¨ˆ
            this.gameStats.totalDamageTaken += attackResult.damage;
            
            this.player.takeDamage(attackResult.damage);
            this.updateUI();
            
            // æª¢æŸ¥ç©å®¶æ˜¯å¦æ­»äº¡
            if (!this.player.isAlive()) {
                await this.handlePlayerDefeated();
                return;
            }
        } else {
            this.addCombatMessage(`ğŸ¯ æ•µäººæ”»æ“Šæœªå‘½ä¸­ï¼é€ æˆ 1 é»å‚·å®³`);
            this.player.takeDamage(1);
            this.gameStats.totalDamageTaken += 1;
            this.updateUI();
        }
        
        // æ›´æ–°ä¸‹ä¸€æ¬¡æ”»æ“Šé è¦½
        this.updateEnemyNextAttack();
        
        await this.delay(800);
    }

    async handleEnemyDefeated() {
        const battleTime = ((Date.now() - this.battleStartTime) / 1000).toFixed(1);
        this.addCombatMessage(`ğŸ‰ æ“Šæ•—æ•µäººï¼æˆ°é¬¥æ™‚é–“: ${battleTime}ç§’`);
        
        this.gameStats.victories++;
        if (window.performanceMonitor) {
            window.performanceMonitor.recordEnemyDefeated();
        }
        
        // æª¢æŸ¥æ˜¯å¦ç²å¾—å¤©è³¦é»
        const earnedTalentPoint = this.checkForTalentPoint(this.enemySystem.enemyCounter);
        
        // ç©å®¶å›å¾©
        const healAmount = 20 + (this.player.healOnVictory || 0);
        const maxHpIncrease = 5;
        
        this.player.heal(healAmount);
        this.player.increaseMaxHealth(maxHpIncrease);
        
        this.addCombatMessage(`â¤ï¸ ç”Ÿå‘½å›å¾© ${healAmount}é»ï¼Œæœ€å¤§ç”Ÿå‘½å¢åŠ  ${maxHpIncrease}é»`);
        
        // å¦‚æœä¸æ˜¯ç²å¾—å¤©è³¦é»çš„æ•µäººï¼Œé¡¯ç¤ºçå‹µé¸æ“‡
        if (!earnedTalentPoint) {
            await this.showRewardSelection();
        }
        
        // ç²å–ä¸‹ä¸€å€‹æ•µäºº
        this.currentEnemy = this.enemySystem.getNextEnemy();
        this.isBattleActive = false;
        
        this.updateUI();
        document.querySelector(CONSTANTS.SELECTORS.START_BATTLE_BTN).disabled = false;
        this.setCardsEnabled(false);
        
        this.addCombatMessage('æº–å‚™å¥½å¾Œé»æ“Šã€Œé–‹å§‹æˆ°é¬¥ã€è¿æ¥ä¸‹ä¸€å€‹æ•µäºº');

        // ç™¼é€æˆ°é¬¥å‹åˆ©äº‹ä»¶
        this.dispatchGameEvent('battleVictory', {
            enemyLevel: this.enemySystem.enemyCounter - 1,
            battleTime: parseFloat(battleTime),
            damageDealt: this.gameStats.totalDamageDealt
        });
    }

    async handlePlayerDefeated() {
        this.addCombatMessage('ğŸ’€ ä½ è¢«æ“Šæ•—äº†...');
        this.isBattleActive = false;
        this.gameStats.defeats++;
        
        if (window.performanceMonitor) {
            window.performanceMonitor.recordPlayerDeath();
        }
        
        // é‡ç½®ç©å®¶ç”Ÿå‘½å€¼
        this.player.currentHealth = this.player.maxHealth;
        
        await this.delay(2000);
        
        this.addCombatMessage('ğŸ’ª ç”Ÿå‘½å€¼å·²æ¢å¾©ï¼Œæº–å‚™å†æ¬¡æŒ‘æˆ°');
        this.updateUI();
        
        document.querySelector(CONSTANTS.SELECTORS.START_BATTLE_BTN).disabled = false;
        this.setCardsEnabled(false);

        // ç™¼é€æˆ°é¬¥å¤±æ•—äº‹ä»¶
        this.dispatchGameEvent('battleDefeat', {
            enemyLevel: this.enemySystem.enemyCounter,
            damageTaken: this.gameStats.totalDamageTaken
        });
    }

    checkForTalentPoint(enemyNumber) {
        // æ•µäºº001, 004, 007, 010... 079 ç²å¾—å¤©è³¦é»
        if ((enemyNumber - 1) % 3 === 0 && enemyNumber <= 79) {
            this.earnTalentPoint();
            return true;
        }
        return false;
    }

    earnTalentPoint() {
        this.talentPointsEarned++;
        const newPoints = this.talentSystem.addTalentPoint();
        
        this.addCombatMessage(`âœ¨ ç²å¾—å¤©è³¦é»ï¼ç•¶å‰å¤©è³¦é»: ${newPoints}`);
        this.addCombatMessage('é»æ“Šå·¦å´å¤©è³¦é¢æ¿æ¿€æ´»æ–°èƒ½åŠ›');
        
        return newPoints;
    }

    setCardsEnabled(enabled) {
        document.querySelectorAll('.card').forEach(card => {
            card.classList.toggle('disabled', !enabled);
            card.style.pointerEvents = enabled ? 'all' : 'none';
        });
    }

    updateUI() {
        this.updateHealthBars();
        this.updateHealthText();
        this.updatePlayerStats();
        this.updateEnemyLevel();
        this.updateEnemyAttributesDisplay();
        this.updateEnemyNextAttack();
        this.talentSystem.updateTalentPointsDisplay();
        this.updateTurnIndicator();
    }

    updateHealthBars() {
        const playerHealth = this.player.getHealthPercentage();
        const enemyHealth = this.currentEnemy.getHealthPercentage();
        
        const playerBar = document.querySelector(CONSTANTS.SELECTORS.PLAYER_HEALTH);
        const enemyBar = document.querySelector(CONSTANTS.SELECTORS.ENEMY_HEALTH);
        
        if (playerBar) playerBar.style.width = `${playerHealth}%`;
        if (enemyBar) enemyBar.style.width = `${enemyHealth}%`;
    }

    updateHealthText() {
        const playerHealthText = document.querySelector(CONSTANTS.SELECTORS.PLAYER_HEALTH_TEXT);
        const enemyHealthText = document.querySelector(CONSTANTS.SELECTORS.ENEMY_HEALTH_TEXT);
        
        if (playerHealthText) {
            playerHealthText.textContent = `${this.player.currentHealth}/${this.player.maxHealth}`;
        }
        if (enemyHealthText) {
            enemyHealthText.textContent = `${this.currentEnemy.currentHealth}/${this.currentEnemy.maxHealth}`;
        }
    }

    updatePlayerStats() {
        const stats = this.player.getStats();
        const statsElement = document.querySelector(CONSTANTS.SELECTORS.PLAYER_STATS);
        
        if (statsElement) {
            statsElement.textContent = `æ”»:${stats.attack} é˜²:${stats.defense} å‘½:${stats.hitChance}% æš´:${stats.critChance}%`;
        }
    }

    updateEnemyLevel() {
        const levelElement = document.querySelector(CONSTANTS.SELECTORS.ENEMY_LEVEL);
        if (levelElement) {
            levelElement.textContent = this.enemySystem.enemyCounter.toString().padStart(3, '0');
        }
    }

    updateEnemyAttributesDisplay() {
        const attributes = this.enemySystem.getCurrentEnemyAttributes();
        let attributesText = '';
        
        Object.entries(attributes).forEach(([key, value]) => {
            if (value > 0) {
                const attributeName = CONSTANTS.UI.ATTRIBUTE_NAMES[key] || key;
                attributesText += `${attributeName}+${value} `;
            }
        });
        
        const enemyAttributesElement = document.querySelector(CONSTANTS.SELECTORS.ENEMY_ATTRIBUTES);
        if (enemyAttributesElement) {
            enemyAttributesElement.textContent = attributesText || 'ç„¡å±¬æ€§åŠ æˆ';
        }
    }

    updateEnemyNextAttack() {
        const nextAttack = this.enemySystem.getNextAttackDescription();
        this.updateEnemyNextAttackText(nextAttack);
    }

    updateEnemyNextAttackText(attackType) {
        const element = document.querySelector(CONSTANTS.SELECTORS.ENEMY_NEXT_ATTACK);
        if (element) {
            element.textContent = `æ•µäººä¸‹æ¬¡æ”»æ“Šï¼š${attackType}`;
            
            // æ ¹æ“šæ”»æ“Šé¡å‹æ·»åŠ é¡è‰²æç¤º
            element.className = '';
            if (attackType.includes('é‡æ”»æ“Š') || attackType.includes('çŒ›çƒˆ') || attackType.includes('ç‹‚æš´')) {
                element.classList.add('attack-heavy');
            } else if (attackType.includes('ä¸­æ”»æ“Š') || attackType.includes('è¬¹æ…')) {
                element.classList.add('attack-medium');
            } else if (attackType.includes('è¼•æ”»æ“Š')) {
                element.classList.add('attack-light');
            } else if (attackType.includes('ç‰¹æ®Š') || attackType.includes('é˜²ç¦¦')) {
                element.classList.add('attack-special');
            }
        }
    }

    updateTurnIndicator() {
        // æ›´æ–°å›åˆæŒ‡ç¤ºå™¨
        let indicator = document.getElementById('turn-indicator');
        if (!indicator) {
            indicator = document.createElement('div');
            indicator.id = 'turn-indicator';
            indicator.className = 'turn-indicator';
            document.getElementById('action-panel')?.appendChild(indicator);
        }
        
        indicator.className = `turn-indicator ${this.isPlayerTurn ? 'turn-player' : 'turn-enemy'}`;
        indicator.textContent = this.isPlayerTurn ? 'ä½ çš„å›åˆ' : 'æ•µäººå›åˆ';
    }

    addCombatMessage(message) {
        const messagesContainer = document.querySelector(CONSTANTS.SELECTORS.COMBAT_MESSAGES);
        if (!messagesContainer) return;
        
        const messageElement = document.createElement('div');
        messageElement.textContent = `> ${message}`;
        messageElement.className = 'combat-message';
        
        // æ ¹æ“šè¨Šæ¯é¡å‹æ·»åŠ æ¨£å¼
        if (message.includes('æ“Šæ•—') || message.includes('ç²å¾—') || message.includes('å›å¾©')) {
            messageElement.classList.add('message-positive');
        } else if (message.includes('æœªå‘½ä¸­') || message.includes('æ“Šæ•—') || message.includes('æ­»äº¡')) {
            messageElement.classList.add('message-negative');
        } else if (message.includes('å¤©è³¦') || message.includes('çå‹µ')) {
            messageElement.classList.add('message-special');
        }
        
        messagesContainer.appendChild(messageElement);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
        
        // é™åˆ¶è¨Šæ¯æ•¸é‡
        const messages = messagesContainer.querySelectorAll('.combat-message');
        if (messages.length > 50) {
            messages[0].remove();
        }
    }

    async showRewardSelection() {
        this.showingRewards = true;
        
        // ç²å–éš¨æ©Ÿçå‹µ
        const rewards = this.rewardSystem.getRandomRewards(5, this.enemySystem.enemyCounter);
        
        // å‰µå»ºçå‹µé¸æ“‡ç•Œé¢
        const rewardModal = this.createRewardModal(rewards);
        document.body.appendChild(rewardModal);
        
        // ç­‰å¾…ç©å®¶é¸æ“‡
        return new Promise((resolve) => {
            this.rewardResolve = resolve;
        });
    }

    createRewardModal(rewards) {
        const modal = document.createElement('div');
        modal.className = 'reward-modal';
        modal.innerHTML = `
            <div class="reward-modal-content">
                <div class="reward-modal-header">
                    <h3>é¸æ“‡çå‹µ</h3>
                    <p>æ“Šæ•—æ•µäººå¾Œç²å¾—ä»¥ä¸‹çå‹µé¸æ“‡ï¼š</p>
                </div>
                <div class="reward-options-grid">
                    ${rewards.map((reward, index) => `
                        <div class="reward-option ${reward.rarity}" data-reward-id="${reward.id}">
                            <div class="reward-header">
                                <span class="reward-name">${reward.name}</span>
                                <span class="reward-rarity ${reward.rarity}">${this.rewardSystem.getRarityName(reward.rarity)}</span>
                            </div>
                            <div class="reward-description">${reward.description}</div>
                            <div class="reward-type">${this.rewardSystem.getTypeName(reward.type)}</div>
                        </div>
                    `).join('')}
                </div>
                <div class="reward-modal-footer">
                    <p>é¸æ“‡ä¸€å€‹çå‹µä¾†å¢å¼·ä½ çš„èƒ½åŠ›</p>
                </div>
            </div>
        `;
        return modal;
    }

    handleRewardSelection(event) {
        if (!this.showingRewards) return;

        const rewardOption = event.target.closest('.reward-option');
        if (!rewardOption) return;

        const rewardId = parseInt(rewardOption.dataset.rewardId);
        const rewards = this.rewardSystem.allRewards;
        const selectedReward = rewards.find(r => r.id === rewardId);

        if (selectedReward) {
            // æ‡‰ç”¨çå‹µæ•ˆæœ
            const resultMessage = this.rewardSystem.applyReward(selectedReward, this.player);
            this.addCombatMessage(`ğŸ ç²å¾—çå‹µ: ${selectedReward.name} (${resultMessage})`);
            
            this.gameStats.rewardsObtained++;
            
            // ç§»é™¤å½ˆçª—
            const modal = document.querySelector('.reward-modal');
            if (modal) {
                modal.remove();
            }

            this.showingRewards = false;
            if (this.rewardResolve) {
                this.rewardResolve();
            }

            // æ›´æ–°UIé¡¯ç¤ºæ–°å±¬æ€§
            this.updateUI();
        }
    }

    autoLoadGame() {
        const hasSave = SaveSystem.hasSave();
        if (hasSave && confirm('ç™¼ç¾å­˜æª”ï¼Œæ˜¯å¦è¼‰å…¥ï¼Ÿ')) {
            this.loadGame();
        }
    }

    saveGame() {
        return this.saveManager.manualSave();
    }

    loadGame(saveData = null) {
        if (this.isBattleActive) {
            console.log('âŒ æˆ°é¬¥ä¸­ç„¡æ³•è¼‰å…¥éŠæˆ²');
            return false;
        }

        if (!saveData) {
            saveData = SaveSystem.loadGame();
            if (!saveData) return false;
        }

        try {
            // è¼‰å…¥éŠæˆ²æ•¸æ“š
            this.enemySystem.enemyCounter = saveData.enemyCounter || 1;
            this.enemySystem.enemyAttributes = saveData.enemyAttributes || this.enemySystem.initializeEnemyAttributes();
            
            // è¼‰å…¥ç©å®¶æ•¸æ“š
            const playerData = saveData.player || {};
            this.player = new Entity({
                maxHealth: playerData.maxHealth || 100,
                attack: playerData.attack || 0,
                defense: playerData.defense || 0,
                hitChance: playerData.hitChance || 0,
                critChance: playerData.critChance || 0,
                toughness: playerData.toughness || 0,
                dodge: playerData.dodge || 0
            });
            this.player.currentHealth = playerData.currentHealth || this.player.maxHealth;
            this.player.healPerTurn = playerData.healPerTurn || 0;
            this.player.healOnVictory = playerData.healOnVictory || 0;
            this.player.shield = playerData.shield || 0;

            // è¼‰å…¥å¤©è³¦ç³»çµ±
            if (saveData.talentSystem) {
                this.talentSystem.load(saveData.talentSystem);
            }

            this.currentEnemy = this.enemySystem.createEnemy(this.enemySystem.enemyCounter);
            this.updateUI();
            
            this.addCombatMessage('ğŸ’¾ éŠæˆ²è¼‰å…¥å®Œæˆ');
            
            return true;
        } catch (error) {
            console.error('âŒ è¼‰å…¥å¤±æ•—:', error);
            this.addCombatMessage('âŒ å­˜æª”è¼‰å…¥å¤±æ•—');
            return false;
        }
    }

    toggleGameMenu() {
        const menu = document.getElementById('game-controls');
        if (menu) {
            menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
        }
    }

    handleGameReset() {
        this.initializeGame();
        this.addCombatMessage('ğŸ”„ éŠæˆ²å·²é‡ç½®');
    }

    dispatchGameEvent(eventName, detail) {
        const event = new CustomEvent(eventName, { detail });
        document.dispatchEvent(event);
    }

    getGameStats() {
        return { ...this.gameStats };
    }

    delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    cleanup() {
        if (this.saveManager) {
            this.saveManager.cleanup();
        }
    }
}