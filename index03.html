<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>回合制戰鬥遊戲</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Microsoft JhengHei', '微軟正黑體', sans-serif;
        }

        body {
            background: #050510 url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><rect fill="%23050510" width="100" height="100"/><path fill="%23080818" d="M0 0L100 100M100 0L0 100" stroke-width="0.5"/></svg>');
            color: #ccc;
            min-height: 100vh;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            width: 100%;
            max-width: 1350px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 300px 1fr;
            grid-template-rows: 1fr auto;
            gap: 15px;
        }

        header {
            grid-column: 1 / -1;
            text-align: center;
            margin-bottom: 15px;
            padding: 8px;
            border-bottom: 2px solid #2a8cff;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(10, 10, 20, 0.7);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        .game-info {
            display: flex;
            gap: 20px;
        }

        .info-box {
            background: rgba(15, 15, 25, 0.9);
            padding: 10px 15px;
            border-radius: 8px;
            border: 1px solid #2a2a4a;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
        }

        /* 天賦區域 - 左側 */
        .talents-section {
            background: rgba(10, 10, 20, 0.8);
            border-radius: 10px;
            padding: 15px;
            border: 1px solid #2a2a4a;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.6);
            grid-column: 1;
            grid-row: 1;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .talents-section h2 {
            color: #2a8cff;
            text-align: center;
            margin-bottom: 15px;
            padding-bottom: 5px;
            border-bottom: 1px solid #2a2a4a;
            font-size: 1.5rem;
            text-shadow: 0 0 5px rgba(42, 140, 255, 0.3);
        }

        .talents-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .talent-points {
            color: #c82864;
            font-weight: bold;
        }

        .talents-container {
            height: 400px;
            overflow: hidden;
            flex: 1;
        }

        .talents-grid {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            grid-template-rows: repeat(10, 1fr);
            gap: 3px;
            width: 100%;
            height: 100%;
        }

        .talent-cell {
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: rgba(30, 30, 60, 0.3);
            border: 1px solid #2a2a4a;
            font-size: 8px;
            font-weight: bold;
            color: #aaa;
            border-radius: 2px;
            position: relative;
        }

        /* Tooltip */
        .talent-tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.75);
            color: #fff;
            padding: 8px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 100;
            display: none;
            left: 105%;
            top: 50%;
            transform: translateY(-50%);
        }

        .talent-cell.locked {
            background: rgba(20, 20, 40, 0.2);
            cursor: not-allowed;
            opacity: 0.4;
        }

        .talent-cell.available {
            background: rgba(211, 211, 211, 0.3);
            border-color: #d3d3d3;
            animation: pulse 2s infinite;
            color: #fff;
        }

        .talent-cell.activated {
            background: rgba(144, 238, 144, 0.3);
            border-color: rgba(144, 238, 144, 0.8);
            color: #fff;
        }

        /* 遊戲信息 - 移動到天賦區域下方 */
        .game-stats {
            margin-top: 15px;
            padding: 10px;
            background: rgba(15, 15, 25, 0.9);
            border-radius: 8px;
            border: 1px solid #2a2a4a;
            display: flex;
            justify-content: space-between;
        }

        .stat-box {
            text-align: center;
        }

        .stat-box div:first-child {
            font-size: 14px;
            color: #aaa;
        }

        .stat-box div:last-child {
            font-size: 18px;
            font-weight: bold;
            color: #2a8cff;
        }

        /* 戰鬥區域 - 右側 */
        .battle-section {
            display: flex;
            flex-direction: column;
            gap: 15px;
            grid-column: 2;
            grid-row: 1;
            padding: 15px;
            background: rgba(10, 10, 20, 0.8);
            border-radius: 10px;
            border: 1px solid #c82864;
            box-shadow: 0 0 15px rgba(200, 40, 100, 0.3);
        }

        .status-text {
            padding: 10px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 8px;
            min-height: 120px;
            max-height: 120px;
            font-size: 14px;
            line-height: 1.6;
            margin-bottom: 15px;
            overflow-y: auto;
            border: 1px solid #1a1a2a;
        }

        .status-text p {
            margin-bottom: 8px;
            padding: 5px;
            border-bottom: 1px solid rgba(80, 80, 100, 0.2);
        }

        .status-text p:last-child {
            margin-bottom: 0;
            border-bottom: none;
        }

        .enemy-action {
            color: #c82864;
            font-weight: bold;
        }

        .combatants {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin-top: 15px;
            position: relative;
        }

        .character {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .character-box {
            width: 120px;
            height: 120px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border: 3px solid;
            border-radius: 10px;
            font-size: 18px;
            font-weight: bold;
            position: relative;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            transition: all 0.3s ease;
        }

        .player {
            background: linear-gradient(135deg, #0f0f1f 0%, #151525 100%);
            border-color: #2a8cff;
            color: #2a8cff;
        }

        .enemy {
            background: linear-gradient(135deg, #1f0f0f 0%, #251515 100%);
            border-color: #c82864;
            color: #c82864;
        }

        .character-box.low-health {
            opacity: 0.7;
        }

        .character-box.critical-health {
            opacity: 0.5;
        }

        .player-critical-flash {
            animation: flash 0.5s infinite alternate;
        }

        @keyframes flash {
            from { opacity: 1; }
            to { opacity: 0.2; }
        }

        .enemy-id {
            font-size: 14px;
            margin-top: 5px;
            position: relative;
            z-index: 2;
        }

        .hp-bar {
            width: 100%;
            background: rgba(0, 0, 0, 0.4);
            height: 10px;
            border-radius: 5px;
            overflow: hidden;
            position: relative;
            z-index: 2;
        }

        .hp-fill {
            height: 100%;
            border-radius: 5px;
            transition: width 0.5s ease;
        }

        .player .hp-fill {
            background: linear-gradient(90deg, #2a8cff 0%, #1a6cdf 100%);
        }

        .enemy .hp-fill {
            background: linear-gradient(90deg, #c82864 0%, #a81844 100%);
        }

        .hp-text {
            font-size: 14px;
            font-weight: bold;
            position: relative;
            z-index: 2;
        }

        .attack-cards {
            display: flex;
            justify-content: space-around;
            gap: 15px;
        }

        .card {
            border-radius: 10px;
            padding: 15px;
            width: 30%;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid #2a2a6a;
            position: relative;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
        }

        .card.disabled {
            opacity: 0.5;
            pointer-events: none;
        }

        /* 修正: 卡片被使用後的遮罩效果 */
        .card .card-mask {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 1);
            z-index: 5;
            transition: opacity 0.5s ease;
            opacity: 0;
            pointer-events: none;
        }

        .card.used .card-mask {
            opacity: 1;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 25px rgba(42, 140, 255, 0.4);
            border-color: #2a8cff;
        }

        .card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 5px;
            background: rgba(42, 140, 255, 0.5);
        }

        .card h3 {
            color: #2a8cff;
            margin-bottom: 10px;
            font-size: 18px;
        }

        .card p {
            font-size: 14px;
            margin-bottom: 5px;
            color: #bbb;
        }

        .card .damage {
            font-size: 24px;
            font-weight: bold;
            color: white;
            margin: 10px 0;
        }

        .card.light {
            background: linear-gradient(135deg, rgba(169, 167, 166, 0.1) 0%, rgba(169, 167, 166, 0.2) 100%);
        }

        .card.medium {
            background: linear-gradient(135deg, rgba(255, 140, 0, 0.1) 0%, rgba(255, 140, 0, 0.2) 100%);
        }

        .card.heavy {
            background: linear-gradient(135deg, #301525 0%, #401525 100%);
        }

        .turn-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 5px 10px;
            border-radius: 15px;
            font-weight: bold;
            border: 1px solid #2a8cff;
            box-shadow: 0 0 8px rgba(42, 140, 255, 0.5);
            display: none;
            text-align: center;
            font-size: 12px;
            z-index: 10;
            min-width: 80px;
        }

        .turn-indicator.player-turn {
            border-color: #2a8cff;
            color: #2a8cff;
        }

        .turn-indicator.enemy-turn {
            border-color: #c82864;
            color: #c82864;
        }

        .enemy-thinking {
            display: flex;
            gap: 3px;
            align-items: center;
            justify-content: center;
            margin-top: 3px;
        }

        .thinking-dot {
            width: 5px;
            height: 5px;
            background: #c82864;
            border-radius: 50%;
            animation: thinking 1.5s infinite;
        }

        .thinking-dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .thinking-dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        /* 迷你遊戲容器 */
        .minigame-container {
            position: absolute;
            top: 25%;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
            height: 100px;
            background: #1a1a1a;
            border-radius: 5px;
            border: 1px solid #ccc;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 10px;
            z-index: 20;
        }
        
        .minigame-container h3 {
            color: #2a8cff;
            margin-bottom: 5px;
        }

        .minigame-container p.damage-text {
            color: #ff4d4d;
            font-weight: bold;
            font-size: 20px;
            text-shadow: 0 0 5px #ff4d4d;
        }

        /* 超感受迷你遊戲樣式 */
        #ultra-sensation-bar {
            width: 90%;
            height: 20px;
            background: #aaa;
            border-radius: 10px;
            position: relative;
            overflow: hidden;
            margin-top: 10px;
        }

        #ultra-sensation-red {
            position: absolute;
            width: 20%;
            height: 100%;
            background: #e74c3c;
            left: 40%;
            z-index: 1;
        }

        #ultra-sensation-ball {
            position: absolute;
            width: 18px;
            height: 18px;
            background: #2ecc71;
            border-radius: 50%;
            top: 1px;
            left: 0;
            z-index: 2;
        }

        /* 招架迷你遊戲樣式 */
        #parry-timer {
            font-size: 28px;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 5px #2a8cff;
        }

        .action-button {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #2a8cff 0%, #1a6cdf 100%);
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 8px rgba(42, 140, 255, 0.5);
            z-index: 10;
            min-width: 80px;
        }

        .action-button:hover {
            transform: translate(-50%, -50%) scale(1.05);
            box-shadow: 0 0 12px rgba(42, 140, 255, 0.7);
        }

        .minigame-action-button {
            top: 65%;
        }

        .minigame-action-button.parry {
            background: linear-gradient(135deg, #c82864 0%, #a81844 100%);
            box-shadow: 0 0 8px rgba(200, 40, 100, 0.5);
        }

        .minigame-action-button.ultra-sensation {
            background: linear-gradient(135deg, #2ecc71 0%, #25a45a 100%);
            box-shadow: 0 0 8px rgba(46, 204, 113, 0.5);
        }

        /* 動畫效果 */
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(211, 211, 211, 0.7); }
            70% { box-shadow: 0 0 0 5px rgba(211, 211, 211, 0); }
            100% { box-shadow: 0 0 0 0 rgba(211, 211, 211, 0); }
        }

        @keyframes thinking {
            0%, 100% { transform: scale(1); opacity: 0.7; }
            50% { transform: scale(1.5); opacity: 1; }
        }

        /* 響應式設計 */
        @media (max-width: 900px) {
            .container {
                grid-template-columns: 1fr;
            }
            .talents-section {
                grid-column: 1;
                grid-row: 3;
            }
            .battle-section {
                grid-column: 1;
                grid-row: 2;
            }
            .attack-cards {
                flex-direction: column;
                align-items: center;
            }
            .card {
                width: 80%;
                margin-bottom: 15px;
            }
            .talents-container {
                height: 300px;
            }
            .game-stats {
                flex-direction: column;
                gap: 10px;
            }

            .turn-indicator, .action-button {
                font-size: 10px;
                padding: 4px 8px;
                min-width: 70px;
            }

            .minigame-container {
                width: 90%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <section class="talents-section">
            <div class="talents-header">
                <h2>戰鬥天賦</h2>
                <div class="talent-points">可配置點數: <span id="available-points">0</span></div>
            </div>
            <div class="talents-container">
                <div class="talents-grid" id="talents-grid">
                </div>
            </div>
            <div class="game-stats">
                <div class="stat-box">
                    <div>回合數</div>
                    <div id="turn-counter">1</div>
                </div>
                <div class="stat-box">
                    <div>玩家等級</div>
                    <div id="player-level">0</div>
                </div>
                <div class="stat-box">
                    <div>敵人</div>
                    <div id="enemy-id">001</div>
                </div>
            </div>
        </section>
        <section class="battle-section">
            <div class="status-text" id="battle-log">
                <p>點擊「戰鬥開始」按鈕開始遊戲！</p>
            </div>
            <div class="combatants">
                <div class="character">
                    <div class="character-box player" id="player-character" title="每回合恢復1HP">
                        玩家
                        <div class="enemy-id">Lv.<span id="player-level-display">0</span></div>
                    </div>
                    <div class="hp-bar">
                        <div class="hp-fill" id="player-hp-bar" style="width: 100%;"></div>
                    </div>
                    <div class="hp-text" id="player-hp-text">100/100</div>
                </div>

                <div class="turn-indicator" id="turn-indicator">
                    <div id="turn-text"></div>
                    <div class="enemy-thinking" id="enemy-thinking">
                        <div class="thinking-dot"></div>
                        <div class="thinking-dot"></div>
                        <div class="thinking-dot"></div>
                    </div>
                </div>

                <button class="action-button" id="start-button" style="display: none;">戰鬥開始</button>

                <button class="action-button" id="continue-button" style="display: none;">繼續戰鬥</button>

                <button class="action-button minigame-action-button" id="minigame-action-button" style="display: none;"></button>

                <div id="parry-minigame" class="minigame-container" style="display: none;">
                    <h3>招架</h3>
                    <p class="damage-text" id="parry-damage-text"></p>
                    <div id="parry-timer">0.00</div>
                    <p>在時間停在11.0 +/- 0.2秒時點擊招架按鈕</p>
                </div>

                <div id="ultra-sensation-minigame" class="minigame-container" style="display: none;">
                    <h3>超感受</h3>
                    <p class="damage-text" id="ultra-sensation-damage-text"></p>
                    <div id="ultra-sensation-bar">
                        <div id="ultra-sensation-red"></div>
                        <div id="ultra-sensation-ball"></div>
                    </div>
                    <p>在綠球進入紅色區域時點擊按鈕</p>
                </div>

                <div class="character">
                    <div class="character-box enemy" id="enemy-character">
                        敵人
                        <div class="enemy-id"><span id="enemy-id-display">001</span></div>
                    </div>
                    <div class="hp-bar">
                        <div class="hp-fill" id="enemy-hp-bar" style="width: 100%;"></div>
                    </div>
                    <div class="hp-text" id="enemy-hp-text">100/100</div>
                </div>
            </div>
            <div class="attack-cards" id="attack-cards">
            </div>
        </section>
    </div>
    <div id="talent-tooltip" class="talent-tooltip"></div>
    <script>
        // 遊戲狀態
        const gameState = {
            playerHP: 100,
            enemyHP: 100,
            playerTurn: false,
            gameStarted: false,
            gameOver: false,
            turnCount: 1,
            playerLevel: 0,
            enemyCount: 1,
            availableTalentPoints: 0,
            talentLevels: [1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 66, 78, 91, 105],
            talentUnlockLevels: {
                1: 5,
                3: 10,
                6: 15,
                10: 20,
                15: 30,
                21: 40,
                28: 50,
                36: 60,
                45: 70,
                55: 80,
                66: 90,
                78: 100,
            },
            activatedTalents: [],
            attackTypes: {
                light: { name: "輕攻擊", damage: 16, hitChance: 0.82, critChance: 0.05, class: "light" },
                medium: { name: "中攻擊", damage: 24, hitChance: 0.74, critChance: 0.10, class: "medium" },
                heavy: { name: "重攻擊", damage: 30, hitChance: 0.67, critChance: 0.30, class: "heavy" }
            },
            enemyAttackTypes: {
                light: { name: "輕攻擊", damage: 16, hitChance: 0.87, critChance: 0.05 },
                medium: { name: "中攻擊", damage: 24, hitChance: 0.79, critChance: 0.10 },
                heavy: { name: "重攻擊", damage: 30, hitChance: 0.72, critChance: 0.30 }
            },
            battleLog: [],
            currentCards: [],
            parryUses: 0,
            ultraSensationUses: 0,
            enemyMaxHP: 100,
            enemyDefense: 0,
        };

        // DOM 元素
        const battleLogElement = document.getElementById('battle-log');
        const playerHpBar = document.getElementById('player-hp-bar');
        const playerHpText = document.getElementById('player-hp-text');
        const enemyHpBar = document.getElementById('enemy-hp-bar');
        const enemyHpText = document.getElementById('enemy-hp-text');
        const turnCounter = document.getElementById('turn-counter');
        const playerLevelElement = document.getElementById('player-level');
        const playerLevelDisplay = document.getElementById('player-level-display');
        const enemyId = document.getElementById('enemy-id');
        const enemyIdDisplay = document.getElementById('enemy-id-display');
        const talentsGrid = document.getElementById('talents-grid');
        const attackCardsContainer = document.getElementById('attack-cards');
        const availablePoints = document.getElementById('available-points');
        const playerCharacter = document.getElementById('player-character');
        const enemyCharacter = document.getElementById('enemy-character');
        const startButton = document.getElementById('start-button');
        const turnIndicator = document.getElementById('turn-indicator');
        const turnText = document.getElementById('turn-text');
        const enemyThinking = document.getElementById('enemy-thinking');
        const continueButton = document.getElementById('continue-button');
        const talentTooltip = document.getElementById('talent-tooltip');

        // 迷你遊戲DOM元素
        const parryMinigame = document.getElementById('parry-minigame');
        const parryTimer = document.getElementById('parry-timer');
        const parryDamageText = document.getElementById('parry-damage-text');
        const ultraSensationMinigame = document.getElementById('ultra-sensation-minigame');
        const ultraSensationDamageText = document.getElementById('ultra-sensation-damage-text');
        const ultraSensationBall = document.getElementById('ultra-sensation-ball');
        const minigameActionButton = document.getElementById('minigame-action-button');

        // 天賦說明資料
        const talentDescriptions = {
            1: "[招架]: 受到攻擊時50%機率觸發，成功招架可使傷害歸零。每位敵人可觸發兩次。",
            2: "[超感受]: 受到攻擊時50%機率觸發，成功防禦可使傷害歸零。每位敵人可觸發兩次。"
        };
        for (let i = 3; i <= 100; i++) {
            talentDescriptions[i] = `天賦 ${i}: 這是一個功能強大的天賦效果！`;
        }

        // 更新天賦格子的顯示狀態
        function updateTalentsGrid() {
            const unlockedTalentsCount = gameState.talentUnlockLevels[gameState.playerLevel] || 0;
            const cells = talentsGrid.children;

            for (let i = 0; i < 100; i++) {
                const cell = cells[i];
                const talentIndex = i + 1;
                cell.textContent = talentIndex;
                cell.dataset.index = talentIndex;

                cell.className = 'talent-cell';

                if (talentIndex <= unlockedTalentsCount) {
                    if (gameState.activatedTalents.includes(talentIndex)) {
                        cell.classList.add('activated');
                        if (gameState.gameOver) {
                            cell.addEventListener('click', deactivateTalent);
                        } else {
                            cell.removeEventListener('click', deactivateTalent);
                        }
                        cell.removeEventListener('click', activateTalent);
                        cell.style.cursor = 'pointer';
                    } else {
                        cell.classList.add('available');
                        cell.addEventListener('click', activateTalent);
                        cell.removeEventListener('click', deactivateTalent);
                        cell.style.cursor = 'pointer';
                    }
                } else {
                    cell.classList.add('locked');
                    cell.removeEventListener('click', activateTalent);
                    cell.removeEventListener('click', deactivateTalent);
                    cell.style.cursor = 'not-allowed';
                }
            }
        }

        // 顯示天賦說明視窗
        function showTooltip(e) {
            const index = e.target.dataset.index;
            if (index) {
                talentTooltip.textContent = talentDescriptions[index];
                talentTooltip.style.display = 'block';
                talentTooltip.style.left = `${e.target.offsetLeft + e.target.offsetWidth + 5}px`;
                talentTooltip.style.top = `${e.target.offsetTop + e.target.offsetHeight / 2}px`;
            }
        }

        // 隱藏天賦說明視窗
        function hideTooltip() {
            talentTooltip.style.display = 'none';
        }

        // 激活天賦
        function activateTalent(e) {
            const index = parseInt(e.target.dataset.index);
            if (gameState.availableTalentPoints > 0 && !gameState.activatedTalents.includes(index) && gameState.gameOver) {
                gameState.availableTalentPoints--;
                gameState.activatedTalents.push(index);
                updateGameInfo();
                updateTalentsGrid();
            }
        }

        // 撤銷天賦
        function deactivateTalent(e) {
            const index = parseInt(e.target.dataset.index);
            if (gameState.activatedTalents.includes(index) && gameState.gameOver) {
                gameState.availableTalentPoints++;
                const talentIndex = gameState.activatedTalents.indexOf(index);
                gameState.activatedTalents.splice(talentIndex, 1);
                updateGameInfo();
                updateTalentsGrid();
            }
        }

        // 初始化天賦網格
        function initTalentsGrid() {
            talentsGrid.innerHTML = '';
            for (let i = 0; i < 100; i++) {
                const cell = document.createElement('div');
                cell.classList.add('talent-cell');
                talentsGrid.appendChild(cell);
            }
        }

        // 更新遊戲資訊
        function updateGameInfo() {
            turnCounter.textContent = gameState.turnCount;
            playerLevelElement.textContent = gameState.playerLevel;
            playerLevelDisplay.textContent = gameState.playerLevel;
            enemyId.textContent = gameState.enemyCount;
            enemyIdDisplay.textContent = gameState.enemyCount.toString().padStart(3, '0');
            availablePoints.textContent = gameState.availableTalentPoints;
        }

        // 更新血量顯示和視覺效果
        function updateHP() {
            playerHpBar.style.width = `${Math.max(0, gameState.playerHP / 100 * 100)}%`;
            playerHpText.textContent = `${Math.max(0, gameState.playerHP)}/100`;

            enemyHpBar.style.width = `${Math.max(0, gameState.enemyHP / gameState.enemyMaxHP * 100)}%`;
            enemyHpText.textContent = `${Math.max(0, gameState.enemyHP)}/${gameState.enemyMaxHP}`;

            playerCharacter.classList.remove('low-health', 'critical-health', 'player-critical-flash');
            if (gameState.playerHP <= 25) {
                playerCharacter.classList.add('critical-health');
            } else if (gameState.playerHP <= 50) {
                playerCharacter.classList.add('low-health');
            }

            if (gameState.playerHP === 0.1) {
                playerCharacter.classList.add('player-critical-flash');
            }
        }

        // 增加戰鬥日誌
        function addBattleLog(message, isEnemyAction = false) {
            const p = document.createElement('p');
            p.textContent = message;
            if (isEnemyAction) {
                p.classList.add('enemy-action');
            }
            battleLogElement.appendChild(p);
            battleLogElement.scrollTop = battleLogElement.scrollHeight;
        }

        // 移除所有卡片
        function clearCards() {
            attackCardsContainer.innerHTML = '';
        }

        function createCardElement(type) {
            const cardData = gameState.attackTypes[type];
            const cardElement = document.createElement('div');
            cardElement.classList.add('card', cardData.class);
            cardElement.dataset.type = type;
            cardElement.innerHTML = `
                <div class="card-mask"></div>
                <h3>${cardData.name}</h3>
                <p>命中率: ${(cardData.hitChance * 100).toFixed(0)}%</p>
                <p>暴擊率: ${(cardData.critChance * 100).toFixed(0)}%</p>
                <div class="damage">${cardData.damage}</div>
                <p>傷害</p>
                ${gameState.enemyCount === 1 ? '<p style="font-size: 10px; margin-top: 5px; color: #ff6666;">失手可能承受反擊</p>' : ''}
            `;
            return cardElement;
        }

        function drawCard(usedCardElement) {
            setTimeout(() => {
                const cardTypes = Object.keys(gameState.attackTypes);
                const randomType = cardTypes[Math.floor(Math.random() * cardTypes.length)];
                const newCard = createCardElement(randomType);
                newCard.addEventListener('click', () => handleCardSelection(randomType, newCard));
                attackCardsContainer.replaceChild(newCard, usedCardElement);
                const index = gameState.currentCards.indexOf(usedCardElement);
                if (index > -1) {
                    gameState.currentCards.splice(index, 1, newCard);
                }
                addBattleLog("你抽到了一張新的攻擊卡片！");
            }, 2000);
        }

        // 產生初始攻擊卡片
        function generateInitialCards() {
            clearCards();
            gameState.currentCards = [];
            for (const type in gameState.attackTypes) {
                const cardElement = createCardElement(type);
                cardElement.addEventListener('click', () => handleCardSelection(type, cardElement));
                attackCardsContainer.appendChild(cardElement);
                gameState.currentCards.push(cardElement);
            }
        }

        // 處理卡片選擇
        function handleCardSelection(type, cardElement) {
            // 修正: 敵人血量歸零後無法繼續攻擊
            if (gameState.gameOver) return;

            disableCards();
            cardElement.classList.add('used');

            setTimeout(() => {
                attack(type, true, cardElement);
            }, 2000);
        }

        // 啟用/禁用卡片
        function enableCards() {
            gameState.currentCards.forEach(card => {
                card.classList.remove('disabled', 'used');
            });
        }

        function disableCards() {
            gameState.currentCards.forEach(card => {
                card.classList.add('disabled');
            });
        }

        // 顯示回合指示器
        function showTurnIndicator(isPlayerTurn) {
            turnIndicator.style.display = 'block';
            if (isPlayerTurn) {
                turnIndicator.className = 'turn-indicator player-turn';
                turnText.textContent = '你的回合';
                enemyThinking.style.display = 'none';
            } else {
                turnIndicator.className = 'turn-indicator enemy-turn';
                turnText.textContent = '敵人回合';
                enemyThinking.style.display = 'flex';
            }
            startButton.style.display = 'none';
            continueButton.style.display = 'none';
            hideMinigames();
            minigameActionButton.style.display = 'none';
        }

        // 隱藏回合指示器
        function hideTurnIndicator() {
            turnIndicator.style.display = 'none';
        }

        // 隱藏迷你遊戲
        function hideMinigames() {
            parryMinigame.style.display = 'none';
            ultraSensationMinigame.style.display = 'none';
        }

        // 執行攻擊
        function attack(type, isPlayer, usedCardElement = null) {
            const attackerState = isPlayer ? gameState.attackTypes[type] : gameState.enemyAttackTypes[type];
            const targetHP = isPlayer ? 'enemyHP' : 'playerHP';
            const attackerName = isPlayer ? '玩家' : `敵人${gameState.enemyCount}`;

            let damage = attackerState.damage;
            let hit = Math.random() < attackerState.hitChance;
            let crit = hit && Math.random() < attackerState.critChance;

            if (crit) {
                damage *= 2;
            }

            if (isPlayer) {
                // 修正: 玩家攻擊時扣除敵人防禦
                damage = Math.max(0, damage - gameState.enemyDefense);
            }

            if (hit) {
                gameState[targetHP] = Math.max(0, gameState[targetHP] - damage);
            } else {
                damage = 0;
            }

            addBattleLog(`${attackerName}發動了 ${attackerState.name} 攻擊，${hit ? '成功' : '失手'}！造成${damage}點傷害。`, !isPlayer);

            updateHP();

            if (isPlayer && usedCardElement) {
                drawCard(usedCardElement);
            }

            if (!checkGameOver()) {
                if (isPlayer) {
                    gameState.playerHP = Math.min(100, gameState.playerHP + 1);
                    updateHP();
                }
                if (isPlayer) {
                    gameState.turnCount++;
                }
                updateGameInfo();

                setTimeout(() => {
                    if (isPlayer) {
                        enemyTurn();
                    } else {
                        playerTurn();
                    }
                }, 1000);
            }
        }

        // 檢查遊戲是否結束
        function checkGameOver() {
            if (gameState.playerHP <= 0 && gameState.enemyCount === 1) {
                gameState.gameOver = true;
                disableCards();
                hideTurnIndicator();
                addBattleLog('就在我要戰敗的時刻...我突然感覺到..某個...巨大力量的驅使...當我回過神來..敵人已經倒下了..究竟是我身體內的力量 還是有人在默默幫助我...這力量大到...我無法判斷...');
                gameState.playerHP = 0.1;
                updateHP();
                setTimeout(() => {
                    addBattleLog(`你擊敗了敵人${gameState.enemyCount}！`);
                    gameState.playerLevel++;
                    if (gameState.talentLevels.includes(gameState.playerLevel)) {
                        gameState.availableTalentPoints++;
                        addBattleLog(`升級至Lv.${gameState.playerLevel}，獲得1點天賦點！`);
                    }
                    updateGameInfo();
                    updateTalentsGrid();
                    continueButton.style.display = 'block';
                }, 4000);
                return true;
            } else if (gameState.playerHP <= 0) {
                gameState.gameOver = true;
                addBattleLog('你戰敗了！遊戲結束。');
                disableCards();
                hideTurnIndicator();
                startButton.style.display = 'block';
                startButton.textContent = '重新開始';
                return true;
            } else if (gameState.enemyHP <= 0) {
                gameState.gameOver = true;
                addBattleLog(`你擊敗了敵人${gameState.enemyCount}！`);
                disableCards();
                hideTurnIndicator();
                gameState.playerLevel++;
                if (gameState.talentLevels.includes(gameState.playerLevel)) {
                    gameState.availableTalentPoints++;
                    addBattleLog(`升級至Lv.${gameState.playerLevel}，獲得1點天賦點！`);
                }
                updateGameInfo();
                updateTalentsGrid();
                continueButton.style.display = 'block';
                return true;
            }
            return false;
        }

        // 迷你遊戲邏輯
        let parryInterval;
        let parryTimeout;
        let parryStartTime;
        let ultraSensationInterval;
        let ballDirection = 1;

        function startParryMinigame(damage) {
            parryMinigame.style.display = 'flex';
            parryDamageText.textContent = `即將承受 ${damage} 點傷害！`;
            minigameActionButton.style.display = 'block';
            minigameActionButton.textContent = "招架";
            minigameActionButton.classList.add('minigame-action-button', 'parry');

            minigameActionButton.replaceWith(minigameActionButton.cloneNode(true));
            const newMinigameActionButton = document.getElementById('minigame-action-button');
            newMinigameActionButton.addEventListener('click', () => {
                checkParryResult(damage);
            });

            parryStartTime = Date.now();
            parryInterval = setInterval(() => {
                const elapsed = (Date.now() - parryStartTime) / 1000;
                parryTimer.textContent = elapsed.toFixed(2);
            }, 10);

            parryTimeout = setTimeout(() => {
                checkParryResult(damage, true);
            }, 15000);

            addBattleLog(`敵人即將對你造成 ${damage} 點傷害，準備招架!`);
        }

        function checkParryResult(damage, isTimeout = false) {
            clearInterval(parryInterval);
            clearTimeout(parryTimeout);
            const elapsed = parseFloat(parryTimer.textContent);
            parryMinigame.style.display = 'none';
            minigameActionButton.style.display = 'none';
            minigameActionButton.classList.remove('parry');

            if (isTimeout) {
                addBattleLog("招架失敗，超時未按鈕。", true);
                gameState.playerHP = Math.max(0, gameState.playerHP - damage);
                updateHP();
            } else if (elapsed >= 10.8 && elapsed <= 11.2) {
                addBattleLog("招架成功！你擋下了所有傷害！", true);
                gameState.parryUses++;
            } else {
                addBattleLog("招架失敗，你受到了傷害。", true);
                gameState.playerHP = Math.max(0, gameState.playerHP - damage);
                updateHP();
            }

            checkGameOver();

            if (!gameState.gameOver) {
                setTimeout(() => playerTurn(), 1000);
            }
        }

        function startUltraSensationMinigame(damage) {
            ultraSensationMinigame.style.display = 'flex';
            ultraSensationDamageText.textContent = `即將承受 ${damage} 點傷害！`;
            minigameActionButton.style.display = 'block';
            minigameActionButton.textContent = "超感受";
            minigameActionButton.classList.add('minigame-action-button', 'ultra-sensation');

            minigameActionButton.replaceWith(minigameActionButton.cloneNode(true));
            const newMinigameActionButton = document.getElementById('minigame-action-button');
            newMinigameActionButton.addEventListener('click', () => {
                checkUltraSensationResult(damage);
            });

            const bar = ultraSensationMinigame.querySelector('#ultra-sensation-bar');
            const ball = ultraSensationBall;
            const barWidth = bar.offsetWidth;
            let ballPosition = 0;

            ultraSensationInterval = setInterval(() => {
                ballPosition += ballDirection * 2;
                if (ballPosition >= barWidth - ball.offsetWidth || ballPosition <= 0) {
                    ballDirection *= -1;
                }
                ball.style.left = `${ballPosition}px`;
            }, 10);
            addBattleLog(`敵人即將對你造成 ${damage} 點傷害，準備超感受!`);
        }

        function checkUltraSensationResult(damage) {
            clearInterval(ultraSensationInterval);
            ultraSensationMinigame.style.display = 'none';
            minigameActionButton.style.display = 'none';
            minigameActionButton.classList.remove('ultra-sensation');

            const ballPosition = ultraSensationBall.offsetLeft;
            const barWidth = ultraSensationMinigame.querySelector('#ultra-sensation-bar').offsetWidth;
            const redStart = barWidth * 0.4;
            const redEnd = barWidth * 0.6;

            if (ballPosition >= redStart && ballPosition <= redEnd) {
                addBattleLog("超感受成功！你預知了攻擊，閃避了所有傷害！", true);
                gameState.ultraSensationUses++;
            } else {
                addBattleLog("超感受失敗，你受到了傷害。", true);
                gameState.playerHP = Math.max(0, gameState.playerHP - damage);
                updateHP();
            }

            checkGameOver();

            if (!gameState.gameOver) {
                setTimeout(() => playerTurn(), 1000);
            }
        }

        // 開始下一場戰鬥
        function startNextBattle() {
            const isSpecialScenario = gameState.playerHP === 0.1;
            gameState.enemyCount++;
            
            // 修正: 敵人血量和防禦根據敵人編號增加
            gameState.enemyMaxHP = 100 + (gameState.enemyCount > 2 ? (gameState.enemyCount - 2) * 10 : 0);
            gameState.enemyHP = gameState.enemyMaxHP;
            gameState.enemyDefense = gameState.enemyCount > 2 ? gameState.enemyCount - 2 : 0;

            gameState.turnCount = 1;
            gameState.gameOver = false;
            gameState.parryUses = 0;
            gameState.ultraSensationUses = 0;
            if (isSpecialScenario) {
                gameState.playerHP = 21;
                addBattleLog(`你帶著神祕力量的祝福，從生命值21點重新開始戰鬥。`);
            } else {
                gameState.playerHP = Math.min(100, gameState.playerHP + 10);
                addBattleLog(`玩家恢復10點生命值，當前生命值: ${gameState.playerHP}/100`);
            }
            playerCharacter.classList.remove('player-critical-flash');
            updateHP();
            updateGameInfo();
            generateInitialCards();
            addBattleLog(`第 ${gameState.enemyCount} 場戰鬥開始！`);
            continueButton.style.display = 'none';
            playerTurn();
        }

        // 玩家回合
        function playerTurn() {
            gameState.playerTurn = true;
            showTurnIndicator(true);
            enableCards();
            addBattleLog('選擇你的攻擊方式。');
        }

        // 敵方回合
        function enemyTurn() {
            gameState.playerTurn = false;
            showTurnIndicator(false);
            disableCards();
            addBattleLog('敵人正在思考...');

            setTimeout(() => {
                const enemyAttacks = Object.keys(gameState.enemyAttackTypes);
                const randomAttackType = enemyAttacks[Math.floor(Math.random() * enemyAttacks.length)];
                let isTalentUsed = false;

                if (gameState.activatedTalents.includes(1) && gameState.parryUses < 2 && Math.random() < 0.5) {
                    const damage = gameState.enemyAttackTypes[randomAttackType].damage;
                    startParryMinigame(damage);
                    isTalentUsed = true;
                }

                if (!isTalentUsed && gameState.activatedTalents.includes(2) && gameState.ultraSensationUses < 2 && Math.random() < 0.5) {
                    const damage = gameState.enemyAttackTypes[randomAttackType].damage;
                    startUltraSensationMinigame(damage);
                    isTalentUsed = true;
                }

                if (!isTalentUsed) {
                    attack(randomAttackType, false);
                }
            }, 1500);
        }

        // 開始遊戲 (從頭開始)
        function startGame() {
            gameState.gameStarted = true;
            gameState.playerHP = 100;
            gameState.enemyHP = 100;
            gameState.turnCount = 1;
            gameState.playerLevel = 0;
            gameState.enemyCount = 1;
            gameState.availableTalentPoints = 0;
            gameState.gameOver = false;
            gameState.activatedTalents = []; // 修正: 重新開始時清空天賦
            gameState.parryUses = 0;
            gameState.ultraSensationUses = 0;
            gameState.enemyMaxHP = 100;
            gameState.enemyDefense = 0;

            gameState.battleLog = [];
            battleLogElement.innerHTML = '';
            playerCharacter.classList.remove('player-critical-flash');
            updateHP();
            updateGameInfo();
            initTalentsGrid();
            updateTalentsGrid();
            generateInitialCards();
            playerTurn();
        }

        // 初始化事件監聽
        function initGame() {
            initTalentsGrid();
            updateGameInfo();
            updateHP();
            talentsGrid.addEventListener('mouseover', showTooltip);
            talentsGrid.addEventListener('mouseout', hideTooltip);
            startButton.addEventListener('click', startGame);
            continueButton.addEventListener('click', startNextBattle);
            startGame();
        }

        // 頁面載入後初始化
        document.addEventListener('DOMContentLoaded', initGame);
    </script>
</body>
</html>
